<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
		<title>AutoComplete Prototype</title>
		<link type="text/css" href="lib/smoothness/jquery-ui-1.8.16.custom.css" rel="stylesheet" />	
		<script type="text/javascript" src="lib/jquery-1.6.2.min.js"></script>
		<script type="text/javascript" src="lib/jquery-ui-1.8.16.custom.min.js"></script>
		<script type="text/javascript" src="../../js/config.js"></script>
		<script type="text/javascript" src="../../js/query.js"></script>
        <script type="text/javascript" src="lib/jquery.ui.autocomplete.html.js"></script>
        <script type="text/javascript" src="lib/jquery.ui.autocomplete.toggle.js"></script>
        <script type="text/javascript" src="lib/Math.uuid.js"></script>
        <script type="text/javascript" src="lib/jquery.caret.1.02.js"></script>
		<style type="text/css">
            #term-completes ul {
                -webkit-column-count: 5; -webkit-column-gap:20px;
                -moz-column-count:5; -moz-column-gap:20px;
                -o-column-count:5; -o-column-gap:20px;
                column-count:5; column-gap:20px;
            }
            #term-completes .ui-autocomplete {
                width:80%;
            }
		</style>	
	</head>
	<body>
        <script>
            //modifies in place
            function categorize(achit) {
                if(achit.type_ == 'ENTITY') {
                    var i = achit.resolved_.indexOf('/');
                    if(i < 0) {
                        achit.category_ = achit.resolved_.substring(i + 1);
                    } else {
                        achit.category_ = achit.type_;
                    }
                } else {
                    achit.category_ = achit.type_;
                }
            }
            function scoreSort(a,b) {
                if(a.score_ < b.score_) {
                    return 1; 
                } else if(a.score_ > b.score_) {
                    return -1;
                } else {
                    return 0;
                }
            }
            function categorizedSort(a,b) {
                if(a.category_ < b.category_) {
                    return -1; 
                } else if(a.category_ > b.category_) {
                    return 1;
                } else {
                    return scoreSort(a,b);
                }
            }
            function atBeginningOfTerm(s) {
                return /(?:^|[,+\(\)\s])\s*$/.test(s);
            }
            function getOneTerm(before,after) {
                var a = /(?:^|[,+\(\)\s])([^,+\(\)\s]*)$/.exec(before);
                var b = /^[^,+\(\)\s]*/.exec(after);
                return (a[1] + b[0]).replace(/\s*/g, "");
            }
            function getTokens(text) {
                var tokenize = /(?:,|\+|\(|\)|\s+|[a-zA-Z0-9]+)/g;
                var toks = text.match(tokenize);
                if(toks == null)
                    return [];
                return toks;
            }
            var word_expr = /[^,+\(\)\s]+/;
            function getAllTokens(before,after) {
                var a = getTokens(before);
                var b = getTokens(after);
                if(a.length > 0 && b.length > 0) {
                    var a_last = a[a.length - 1];
                    var b_first = b[0];
                    if(word_expr.test(a_last) && word_expr.test(b_first)) {
                        a.pop();
                        b.shift();
                        a.push(a_last + b_first);
                    }
                }
                a.push.apply(a, b);
                return a;
            }
            var ok_or_expr = /[^+\(\)]+/;
            var ok_word_expr = /[^,+\(\)]+/;
            function extractOrList(before,after) {
                var a = getTokens(before);
                var b = getTokens(after);
                if(a.length > 0 && b.length > 0) {
                    var a_last = a[a.length - 1];
                    var b_first = b[0];
                    if(word_expr.test(a_last) && word_expr.test(b_first)) {
                        a.pop();
                        b.shift();
                        a.push(a_last + b_first);
                    }
                }
                var start_or = undefined;
                var start_word = undefined;
                for(var i = a.length - 1; i >= 0; --i) {
                    if(undefined === start_word && !ok_word_expr.test(a[i])) {
                        start_word = i + 1;
                    }
                    if(!ok_or_expr.test(a[i])) {
                        if(a[i] == '(') {
                            start_or = i + 1;
                        }
                        break;
                    }
                }
                if(undefined === start_or) {
                    start_or = 0;
                }
                if(undefined === start_word) {
                    start_word = a.length;
                }
                var end_word = undefined;
                var end_or = undefined;
                for(var i = 0; i < b.length; ++i) {
                    if(!ok_or_expr.test(b[i])) {
                        if(b[i] == ')') {
                            end_or = i;
                        }
                        break;
                    }
                    if(undefined === end_word && !ok_word_expr.test(b[i])) {
                        end_word = i;
                    }
                }
                if(undefined === end_word) {
                    end_word = 0;
                }
                var txt = "";
                if(undefined === start_or || undefined === end_or) {
                    var front = "".concat.apply("", a.slice(start_word));
                    txt = front.concat.apply(front, b.slice(0, end_word));
                } else {
                    var front = "".concat.apply("", a.slice(start_or));
                    txt = front.concat.apply(front, b.slice(0, end_or));
                }
                var terms = txt.replace(/\s+/g, " ").split(',');
                for(var i = 0; i < terms.length; ++i) {
                    terms[i] = terms[i].replace(/(?:^\s*)|(?:\s*$)/g, "");
                }
                return terms;
            }
            function replaceOrList(before,after,replacement_ors) {
                var a = getTokens(before);
                var b = getTokens(after);
                if(a.length > 0 && b.length > 0) {
                    var a_last = a[a.length - 1];
                    var b_first = b[0];
                    if(word_expr.test(a_last) && word_expr.test(b_first)) {
                        a.pop();
                        b.shift();
                        a.push(a_last + b_first);
                    }
                }
                var start_or = undefined;
                var start_word = undefined;
                for(var i = a.length - 1; i >= 0; --i) {
                    if(undefined === start_word && !ok_word_expr.test(a[i])) {
                        start_word = i + 1;
                    }
                    if(!ok_or_expr.test(a[i])) {
                        if(a[i] == '(') {
                            start_or = i + 1;
                        }
                        break;
                    }
                }
                if(undefined === start_or) {
                    start_or = 0;
                }
                if(undefined === start_word) {
                    start_word = a.length;
                }
                var end_word = undefined;
                var end_or = undefined;
                for(var i = 0; i < b.length; ++i) {
                    if(!ok_or_expr.test(b[i])) {
                        if(b[i] == ')') {
                            end_or = i;
                        }
                        break;
                    }
                    if(undefined === end_word && !ok_word_expr.test(b[i])) {
                        end_word = i;
                    }
                }
                if(undefined === end_word) {
                    end_word = 0;
                }
                var replacement = "";
                for(var i = 0; i < replacement_ors.length; ++i) {
                    if(i != 0) replacement += ",";
                    replacement += replacement_ors[i];
                }
                var txt = "";
                if(undefined === start_or || undefined === end_or) {
                    var front = "".concat.apply("", a.slice(0, start_word));
                    front = front.concat(replacement);
                    txt = front.concat.apply(front, b.slice(end_word));
                } else {
                    var front = "".concat.apply("", a.slice(0, start_or));
                    front = front.concat(replacement);
                    txt = front.concat.apply(front, b.slice(end_or));
                }
                var terms = txt.replace(/\s+/g, " ").split(',');
                for(var i = 0; i < terms.length; ++i) {
                    terms[i] = terms[i].replace(/(?:^\s*)|(?:\s*$)/g, "");
                }
                return terms;
            }
            function buildExpression(text) {
                var terms = getTokens(text);
                
            }
            $(function() {
                function autocompleteUpdate(callback, code, response, duration) {
                    $("#duration").text(duration + "ms");
                    if(!success(code)) {
                        alert('query failed\n' + response);
                        callback([]);
                        return;
                    }
                    var top = response.slice(0,50);
                    top.map(categorize);
                    top.sort(categorizedSort);
                    callback(top.map(function(x) { 
                        var id = Math.uuid();
                        var checked = "";
                        if(false) {
                            //TODO, peek at expression and decide if we have this term in the or clause
                            checked = "checked";
                        }
                        return {
                            label:"<input class='autocomplete-check' id='" + id + "' type='checkbox' " + checked + ">" +
                                "<label for='" + id + "'>" + 
                                x.resolved_.substring(0, x.resolved_.indexOf('/')) + " (" + x.score_ + ")" +
                                "</label>",
                            value:x.resolved_.substring(0, x.resolved_.indexOf('/')),
                            category:x.category_,
                        };
                    }));
                }
                
                $( "#query" ).autocomplete(
                    {
                        source:function(req, resp) {
                            var caret = this.caret();
                            console.log(req.term + " : " + req.term.substring(0, caret.start));
                            //if previous char is a space, no ac
                            if(atBeginningOfTerm(req.term.substring(0, caret.start))) {
                                resp([]);
                                return;
                            }
                            var before = req.term.substring(0, caret.start);
                            var after = req.term.substring(caret.start);
                            console.log("all tokens");
                            console.log(getAllTokens(before, after));
                            console.log("or list");
                            console.log(extractOrList(before, after));
                            var term = getOneTerm(before, after);
                            console.log(term);
                            var xhr = buildXHR("GET", "/api/autocomplete/term/" + encodeURIComponent(term), autocompleteUpdate.bind(undefined, resp));
                            xhr.send(null);                
                        }.bind($("#query")),
                        appendTo:$("#term-completes"),
                        html:true,
                        select:function (event, ui) {
                            return false;
                        },
                        focus:function (event, ui) {
                            return false;
                        },
                        commit:function(term) {
                            var caret = $("#query").caret();
                            console.log("commit");
                            var before = term.substring(0, caret.start);
                            var after = term.substring(caret.start);
                            var old_terms = extractOrList(before, after);
                            old_terms.push("%&%");
                            var new_terms = replaceOrList(before, after, old_terms);
                            var replacement = "";
                            for(var i = 0; i < new_terms.length; ++i) {
                                if(i != 0) replacement += ",";
                                replacement += new_terms[i];
                            }
                            var cursor = replacement.indexOf(",%&%");
                            replacement = replacement.replace(",%&%", "");
                            $("#query").attr("value", replacement);
                            $("#query").caret({start:cursor, end:cursor});
                        },
                        revert:function() {
                            console.log("revert");
                        },
                    }
                );
            });
        </script>

        <div class="demo">
            <div class="grid-autocomplete ui-widget">
                <label for="query">Query: </label>
                <input type="text" id="query">Duration: <span id="duration"></span>
            </div>
        </div>     
        <div id="term-completes"></div>
        
        
	</body>
</html>


